I"<h2 id="1-주제">1. 주제</h2>
<p>제 파일럿 프로젝트의 주제는 <em>Vue.js로 만드는 모바일 줌</em> 이었습니다.<br />
Vue.js를 이용해 사이트의 각 기능을 <strong>모듈화</strong>한 모바일 줌 사이트를 만들어 보는 것이죠.
<img src="/images/portal/post/2018-08-23-ZUM-Pilot-partjun/jquery-to-vue.jpg" alt="JQuery에서 Vue.js로" /></p>

<h2 id="2-개발-스펙">2. 개발 스펙</h2>
<p>개발 스펙은 대부분 제가 사용해온 기술 스택이었기 때문에 개발에 있어 큰 어려움을 느끼지는 않았습니다.</p>

<table>
  <thead>
    <tr>
      <th>Back-end</th>
      <th>Front-end</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>- Java8</td>
      <td>- Freemarker</td>
    </tr>
    <tr>
      <td>- Gradle</td>
      <td>- Vue.js</td>
    </tr>
    <tr>
      <td>- Spring Boot</td>
      <td>- Lodash</td>
    </tr>
    <tr>
      <td>- Spring Data</td>
      <td>- Webpack</td>
    </tr>
    <tr>
      <td>- Ehcache</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>이렇게 제시된 기술 스펙에 아래 라이브러리들을 추가로 사용했습니다.</p>

<table>
  <thead>
    <tr>
      <th>Back-end</th>
      <th>Front-end</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>- Lombok</td>
      <td>- Lory</td>
    </tr>
    <tr>
      <td>- H2</td>
      <td>- Axios</td>
    </tr>
    <tr>
      <td> </td>
      <td>- Vue-lazyload</td>
    </tr>
    <tr>
      <td> </td>
      <td>- Sass</td>
    </tr>
  </tbody>
</table>

<h3 id="vuejs">Vue.js?</h3>
<p><img src="/images/portal/post/2018-08-23-ZUM-Pilot-partjun/vue-logo.png" alt="Vue.js 로고" />
<a href="https://kr.vuejs.org/v2/guide/index.html">Vue.js</a>는 프론트엔드 프레임워크입니다. 
2018년 8월 23일 기준으로 111k의 Star를 확보했고, 15k의 Fork 프로젝트가 존재합니다.
그리고 셀 수 없을 정도의 써드파티 라이브러리가 만들어지고 있죠. 명실상부한 ‘대세’ 프레임워크입니다.</p>

<p>많은 프론트엔드 프레임워크가 그렇듯 Vue.js 역시 <a href="https://ko.wikipedia.org/wiki/%EC%8B%B1%EA%B8%80_%ED%8E%98%EC%9D%B4%EC%A7%80_%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98">SPA</a>(Single Page Application)
을 지향하고, 컴포넌트 기반으로 설계됩니다. 또, <a href="https://www.npmjs.com/">NPM</a>으로 디펜전시를 관리하고 
<a href="https://webpack.js.org/">Webpack</a>을 기반으로 Vue/SASS를 비롯한 각종 로더, <a href="https://babeljs.io/">Babel</a> 폴리필등을 사용합니다.
최근 업데이트에서는 <a href="https://www.typescriptlang.org/">TypeScript</a>을 이용한 개발 편의성을 강화하고 있습니다.
<img src="/images/portal/post/2018-08-23-ZUM-Pilot-partjun/what.jpg" alt="??" /> 
<em>프론트엔드 개발을 접하지 않으셨다면 이게 뭔가 싶으실 수 있습니다…</em></p>
<blockquote>
  <p>개인적으로 <em><a href="https://angular.io/">Angular</a>와 비교하자면 아쉬운 점</em>도 있었습니다.<br />
아쉬운 점은 아래 후기에서 말씀드리도록 하죠.</p>
</blockquote>

<h2 id="3-개발-내용">3. 개발 내용</h2>
<p><img src="/images/portal/post/2018-08-23-ZUM-Pilot-partjun/development.jpg" alt="개발 내용" />
<em>프론트엔드 개발 후 백엔드를 개발</em></p>

<p>저는 Stub 데이터를 이용하여 Vue.js 기반의 SPA 프론트엔드 프로젝트를 개발하고 번들링 한 후,<br />
Spring Boot 백엔드 서버를 개발해 합치는 방법을 택했습니다.<br />
그리고 최종적으로 프론트엔드, 백엔드 프로젝트 파일을 통합하여 <a href="https://github.com/srs/gradle-node-plugin">Gradle을 통해 한번에 빌드</a>할 수 있도록 구성했습니다.</p>

<h3 id="front-end-vuejs-project">Front-end: Vue.js Project</h3>
<p>모바일 줌 CMS의 컴포넌트와 라이브러리가 포함된 <em>build.cms_main.js</em> 파일과<br />
CMS 기능이 없는, 일반 사용자를 위한 모바일 줌 컴포넌트만이 포함된 <em>build.main.js</em>
두 개의 파일로 번들링했습니다.
<img src="/images/portal/post/2018-08-23-ZUM-Pilot-partjun/front-bundling.jpg" alt="프론트엔드 번들링" />
<em>두 개의 Entry point를 가지는 웹 앱으로 번들링</em></p>

<p>결과적으로 두 개의 웹앱이 만들어진 셈입니다.</p>

<h4 id="개발-포인트">개발 포인트</h4>
<p><img src="/images/portal/post/2018-08-23-ZUM-Pilot-partjun/front-project-point.jpg" alt="프론트엔드 개발 포인트" />
<em>프론트엔드 개발 포인트</em></p>

<ol>
  <li>컴포넌트 단위 개발
    <ul>
      <li>Side Effect를 최소화하는 <strong>컴포넌트 단위</strong>의 개발
        <blockquote>
          <p>제가 가장 중요하게 여긴 부분입니다.<br />
Side Effect 문제는 함수형 언어를 배워보아야 할 언어로 만들 정도로 아주 중요해졌습니다.
특히 동적 언어이자 Event-Driven 언어인 JS에서는 더욱 조심스럽게 접근해야 한다고 생각합니다.</p>
        </blockquote>
      </li>
      <li>데이터, 이벤트 플로우의 단순화
        <blockquote>
          <p>컴포넌트 간의 데이터 처리와 이벤트 플로우를 간단하고 명료하게 구현하기 위해 노력했습니다.</p>
        </blockquote>
      </li>
    </ul>
  </li>
  <li>SASS(SCSS): 구조적 스타일 및 믹스인 활용
    <ul>
      <li>상하위 구조를 가지는 스타일 시트 작성</li>
      <li>믹스인 및 함수로 작성 코드 최소화
        <blockquote>
          <p>스타일 시트에 개발 시간을 뺏기지 않도록 flex box와 믹스인, 함수등을 활용했습니다.</p>
        </blockquote>
      </li>
    </ul>
  </li>
  <li>Webpack: 핫 리로드 및 번들링
    <ul>
      <li>로더 및 플러그인의 적용(babel, sass, minify)</li>
      <li>변경 사항을 즉각적으로 확인
        <blockquote>
          <p>Webpack Dev Server를 이용해 변경 사항을 즉시 확인하고 테스트함으로서 더 빠른 개발을 할 수 있었습니다.</p>
        </blockquote>
      </li>
    </ul>
  </li>
</ol>

<h3 id="back-end-spring-boot-project">Back-end: Spring Boot Project</h3>
<h4 id="개발-포인트-1">개발 포인트</h4>

<ol>
  <li>템플릿과 관련된 코드 최소화: 주요 로직 집중
    <blockquote>
      <p>아래에서 말씀드릴 <strong>첫 페이지</strong>를 위한 코드 외에는
템플릿 엔진을 이용해 백엔드 데이터를 프론트엔드에 전달하는 보일러 플레이트 코드를 작성할 필요가 없었습니다.</p>
    </blockquote>
  </li>
  <li>Spring Data, Spring Security: 빠르고 강력한 기능들
    <blockquote>
      <p>스프링 데이터를 이용하여 ORM 기반으로 데이터베이스와 모델을 구성했고, 
CMS에서 사용되는 로그인 기능은 스프링 시큐리티를 이용해 구현했습니다.</p>
    </blockquote>
  </li>
  <li>Ehcache를 이용한 캐싱
    <blockquote>
      <p>자주 호출되지만 <strong>갱신이 잦지 않은 서비스</strong>에 대해 캐시를 적용하여 DB 쿼리를 줄였습니다.</p>
    </blockquote>
  </li>
</ol>

<h3 id="프로젝트-url-및-테이블">프로젝트 URL 및 테이블</h3>

<p><img src="/images/portal/post/2018-08-23-ZUM-Pilot-partjun/project-url-control.jpg" alt="프로젝트 URL 구성" />
<em>프로젝트 URL 구성</em></p>

<p>프로젝트의 URL은 위 그림과 같이 심플하게 구성했습니다.<br />
스프링 시큐리티를 이용해 CMS 관련 페이지의 접근을 제한한 것 외에 특별한 사항은 없었습니다.</p>

<p><img src="/images/portal/post/2018-08-23-ZUM-Pilot-partjun/project-erd.jpg" alt="프로젝트 ERD 구성" />
<em>프로젝트 ERD 구성</em></p>

<p>제가 추가한 테이블은 위와 같습니다.<br />
유저당 하나의 네비게이션을 가지고, 네비게이션은 다수의 부모 네비게이션, 부모 네비게이션은 다수의 자식 네비게이션을 가지게 구성했습니다.</p>
<ul>
  <li>로그인하지 않은 유저는 관리자가 컨트롤할 수 있는 기본 네비게이션을 사용합니다.</li>
  <li>네비게이션 스케줄은 부모/자식 네비게이션의 ID를 통해 ON/OFF를 컨트롤합니다.</li>
</ul>

<h3 id="모바일-줌">모바일 줌</h3>
<p><img src="/images/portal/post/2018-08-23-ZUM-Pilot-partjun/mobile-zum-test.gif" alt="구현된 모바일 줌 테스트" width="300px" />
<em>Vue.js로 구현한 모바일 줌 테스트</em></p>

<h4 id="개요">개요</h4>
<p>현재 서비스되고 있는 모바일 줌 페이지를 Vue.js를 이용하여 구현해 보았습니다.<br />
상단 검색바 및 검색어 추천(stub data), 핫이슈, 메인 페이지와 스와이프, 인피니티 스크롤을 통한 랭킹 뉴스 등을 구현했고, 
실제 서비스에서 제공되는 사용자 경험 통계, 사용자별 기능 등은 포함하지 않았습니다.</p>

<h4 id="컴포넌트-구성">컴포넌트 구성</h4>
<p><img src="/images/portal/post/2018-08-23-ZUM-Pilot-partjun/mobile-zum-components.jpg" alt="모바일 줌 컴포넌트 구성" />
<em>모바일 줌 컴포넌트 구성</em></p>

<ul>
  <li>모든 컴포넌트는 Side-effect를 발생시키지 않는 독립적인 컴포넌트로 구성했습니다.</li>
  <li>Navigation 컴포넌트
    <ul>
      <li>Vue의 라우터를 이용하는 일종의 라우팅 컴포넌트입니다.</li>
    </ul>
  </li>
  <li>ZumMain 컴포넌트
    <ul>
      <li>스와이프 기능을 포함하고 있습니다.</li>
      <li>현재 보이는 페이지의 좌/우 페이지를 미리 로드합니다.</li>
      <li><strong>페이지 본문</strong>이 5초간 캐싱됩니다. 따라서 5초 내에 페이지를 다시 열면 서버에 요청하지 않습니다.</li>
    </ul>
  </li>
  <li>페이지 컴포넌트
    <ul>
      <li>공통 기능은 PageMixin이라는 <em>믹스인 컴포넌트</em>로 추상화해 구현했습니다.</li>
      <li>ZumNewsPage
        <ul>
          <li>페이지 최하단에서 내려갈 때 보여지는 <em>랭킹 뉴스</em> 관련 기능을 포함합니다.</li>
        </ul>
      </li>
      <li>ZumHubPage 컴포넌트
        <ul>
          <li>이미지-타이틀로 구성된 허브줌 페이지와 관련된 기능들을 포함합니다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="서버-구성">서버 구성</h4>
<p><img src="/images/portal/post/2018-08-23-ZUM-Pilot-partjun/mobile-zum-server.jpg" alt="모바일 줌 서버 구성" />
<em>모바일 줌 서버 구성</em></p>

<ul>
  <li>일반적인 Controller-Service-Repository 레이어링을 사용했습니다.</li>
  <li>템플릿 엔진: 일부 정보는 DOM으로 구성되어 템플릿에 전달됩니다. 이 정보들을 이용해 아래 컴포넌트를 구성합니다.
    <ul>
      <li>Vue.js 라우터</li>
      <li>유저별 네비게이션(상단 메뉴)</li>
      <li><strong>접속 URL에 해당하는 첫 페이지</strong></li>
    </ul>
  </li>
  <li>임의의 캐시 시간: 카테고리별로 임의의 캐시 타임아웃을 정해 두었습니다.
    <ul>
      <li>네비게이션: 직접 변경 혹은 스케줄링에 따라 네비게이션이 변할 때 캐시를 Eviction하도록 구현했습니다.</li>
    </ul>
  </li>
</ul>

<h4 id="개발-포인트-2">개발 포인트</h4>
<h5 id="믹스인mixin-컴포넌트">믹스인(mixin) 컴포넌트</h5>
<p>뉴스줌 페이지와 허브줌 페이지는 스와이프에 따라 보여지거나 감추고, AJAX를 이용해 페이지를 로드하는 등 기능이 중복됩니다. 
그래서 저는 그런 부분들을 추상화하고 믹스인 컴포넌트로 뽑아내 구현했습니다.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="cm">/**
 * 메인 페이지의 기본 기능을 위한 믹스인 컴포넌트
 * **/</span>
<span class="k">export</span> <span class="k">default</span> <span class="p">{</span>

  <span class="na">data</span><span class="p">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
      <span class="na">isLoading</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span> <span class="c1">// 현재 페이지가 로딩 중인지 여부</span>
      <span class="na">contentData</span><span class="p">:</span> <span class="p">[],</span>  <span class="c1">// 페이지에서 보여줄 컨텐츠의 raw 데이터 </span>
      <span class="na">isHide</span><span class="p">:</span> <span class="kc">true</span>      <span class="c1">// 현재 페이지 노출 여부</span>
    <span class="p">}</span>
  <span class="p">},</span>
  
  <span class="c1">// 실제 구현 생략</span>

<span class="p">}</span></code></pre></figure>

<p>덕분에 중복 코드를 줄이고 해당 컴포넌트에 필요한 객체만을 선언, 구현 할 수 있었습니다.</p>

<h5 id="seosearch-engine-optimize">SEO(Search Engine Optimize)</h5>
<p>자바스크립트 실행을 기반으로 하는 SPA는 그 특성상 크롤러에 노출되기가 쉽지 않습니다. 
대부분의 크롤러는 자바스크립트를 무시하기 때문이죠.</p>
<blockquote>
  <p>하지만 최근 구글 크롤러는 SPA 사이트를 거의 완벽하게 수집하고 있습니다. 앞으로는 신경 쓰지 않아도 될 수 있겠네요.</p>
</blockquote>

<p>웹 사이트의 성향에 따라 <strong>robot.txt</strong> 를 작성하여 
의도적으로 크롤러에 노출되지 않게도 하지만, 대부분의 사이트에 있어 페이지 노출은 아주 중요합니다. 
수익과도 직결되는 문제니까요.</p>

<p><img src="/images/portal/post/2018-08-23-ZUM-Pilot-partjun/google-adsense.jpg" alt="광고=돈" />
<em>광고=돈의 대표 구글 애드센스</em></p>

<p>이 문제를 해결하기 위한 방법이 몇 가지 있습니다.</p>

<h6 id="1-ssr">1. SSR</h6>
<p>말 그대로 Server Side Rendering을 수행하는 방법입니다.<br />
서버에서 HTML 파일을 전해주기 전에 스크립트를 실행하는 방법인데,<br />
자바 서버에서는 <a href="http://openjdk.java.net/projects/nashorn/">Nashorn</a>이나 <a href="https://www.seleniumhq.org/">셀레니움</a>(혹은 PhantomJS)등을 활용할 수 있습니다.<br />
하지만 어떤 방법을 선택해도 스크립트를 실행하는 과정 자체가 오버헤드를 발생시킨다는 점은 피할 수 없습니다.</p>

<h6 id="2-pre-rendering">2. Pre-rendering</h6>
<p>서버에서 HTML을 클라이언트로 전해줄테니, 그 파일 안에 스크립트를 실행한 결과(DOM)를 미리 만들어 넣어두는 방법입니다.<br />
꽤 멋진 방법입니다. 간편하게 적용할 수 있고, 별다른 로직 구현이 필요하지 않습니다.</p>
<blockquote>
  <p>Vue.js는 <a href="https://ko.nuxtjs.org/">Nuxt.js</a>, <a href="https://github.com/chrisvfritz/prerender-spa-plugin">pre-renderer-spa-plugin</a> 등을 이용해 프리렌더링 할 수 있습니다.</p>
</blockquote>

<p>하지만 페이지가 동적으로 자주 변한다면 어떨까요?<br />
번들링을 수행할 때 작성된 파일이니 변화가 없을 것이고, 크롤러가 새로운 정보를 가져가지 못합니다.</p>

<h6 id="3-그럼">3. 그럼…?</h6>
<p>제가 선택한 방법은 앞서 소개해드린 두 가지 방법의 절충안입니다.<br />
<strong>템플릿 엔진</strong>을 이용하여 HTML 파일에 <em>페이지에 사용할 데이터</em>를 DOM으로 만들고, 
클라이언트에서 스크립트를 실행할 때 DOM에 구성되어 있는 <strong>정보</strong>를 파싱하여 페이지에 활용하는 것입니다.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// 모바일 줌 페이지 진입점</span>
<span class="k">new</span> <span class="nx">Vue</span><span class="p">({</span>
  <span class="na">el</span><span class="p">:</span> <span class="dl">'</span><span class="s1">#app</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">router</span><span class="p">:</span> <span class="nx">router</span><span class="p">,</span>
  <span class="na">components</span><span class="p">:</span> <span class="p">{</span><span class="nx">ZumApp</span><span class="p">},</span>
  <span class="na">render</span><span class="p">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">h</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">$el</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">$el</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">h</span><span class="p">(</span><span class="nx">ZumApp</span><span class="p">,</span> <span class="p">{</span>
      <span class="na">props</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">navigation</span><span class="p">:</span> <span class="nx">filteredRoute</span><span class="p">(</span><span class="nx">route</span><span class="p">),</span>
        <span class="na">$topIssue</span><span class="p">:</span> <span class="nx">$el</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">#top-issue</span><span class="dl">'</span><span class="p">),</span> <span class="c1">// 템플릿에 있는 핫이슈</span>
        <span class="na">$zumMain</span><span class="p">:</span> <span class="nx">$el</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">#zum-main</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// 템플릿에 있는 뉴스/허브 등 '메인 페이지'</span>
        <span class="c1">// 물론 템플릿에 아무 데이터도 없다면 서버에 요청합니다.</span>
      <span class="p">}</span>
    <span class="p">});</span>
  <span class="p">}</span>
<span class="p">});</span></code></pre></figure>

<p>클라이언트로 전달되는 DOM이 Vue.js가 실행되어 만들어지는 <em>사용자가 보게 될 DOM</em>과는 다르지만,
노출시키고자 하는 <strong>정보</strong> 자체는 크롤러에 노출됩니다.</p>

<p><img src="/images/portal/post/2018-08-23-ZUM-Pilot-partjun/seo.jpg" alt="SEO 처리된 페이지" />
<em>Postman으로 확인한 페이지의 모습<br />페이지에서 보여줄 기사가 포함되어 있습니다.</em></p>
<blockquote>
  <p>좋은 방법인지는 의문이 남습니다. 파싱-데이터 처리 과정이 추가되기 때문이죠.</p>
</blockquote>

<h5 id="라이브러리-커스터마이즈">라이브러리 커스터마이즈</h5>
<p>모바일 줌 페이지 본문 스와이프 기능은 사용자를 위한 중요한 기능입니다.<br />
저는 이 기능 구현을 위해 <a href="http://meandmax.github.io/lory/">Lory</a>라는 라이브러리를 사용했는데, 
JQuery 기반의 다른 라이브러리들과 다르게 Vanilla JS로 구성되었기 때문입니다. 하지만 <strong>복제된 DOM의 동적인 변화</strong>를 지원하지 않는다는 문제가 있었습니다.</p>

<p>좌-우로 끊임없이 스와이프 할 수 있는 <em>인피니티 스와이프</em> 기능은 첫 페이지와 마지막 페이지에 <strong>복제된 페이지</strong>를 만들어야 합니다. 
첫 페이지에서 좌측으로(마지막 페이지는 우측으로) 스와이프 할 때 마지막 페이지를 보여주어야 하기 때문입니다.</p>

<p><img src="/images/portal/post/2018-08-23-ZUM-Pilot-partjun/infinity-swipe.jpg" alt="인피니티 스와이프 로직" />
<em>infinity swipe 로직</em></p>

<p>라이브러리 내에서 페이지를 복제하고 삽입하는데, 삽입된 이후 원본 페이지를 변화시켜도 복제된 페이지가 변하지 않는 문제가 발생합니다.
저는 이 문제를 해결하기 위해 <strong><a href="https://developer.mozilla.org/ko/docs/Web/API/MutationObserver">MutationObserver</a></strong> 객체를 추가했습니다.<br />
<img src="/images/portal/post/2018-08-23-ZUM-Pilot-partjun/lory-customize.jpg" alt="커스터마이즈된 Lory 라이브러리" /></p>

<p>이 객체를 통해 DOM 수정을 감지할 수 있는데, 
<em>원본</em> 페이지가 변할 때마다 <em>복제</em> 페이지도 갱신하도록 추가 구현하였습니다.</p>

<p><img src="/images/portal/post/2018-08-23-ZUM-Pilot-partjun/swipe-example.gif" alt="본문 스와이프" width="300px" />
<em>구현된 본문 스와이프</em></p>

<blockquote>
  <p>사용하는데 문제는 없지만 커스터마이즈된 라이브러리를 프로젝트에 포함했기 때문에
라이브러리를 최신 버전으로 업데이트하기 까다로워진다는 문제가 생겼습니다.</p>
</blockquote>

<h5 id="virtual-dom-활용">Virtual DOM 활용</h5>
<p>JQuery의 문제점 중 하나로 지목되는 것은 전체 Context를 대상으로 하는 JQuery Selector의 성능 문제입니다.
물론 이 문제는 Query Context를 제한함으로서 해결할 수 있습니다.</p>

<p>하지만 모바일 줌 페이지에서는 페이지 전체 Context를 대상으로 쿼리하는 JQuery Selector가 자주 사용되고 있었습니다.
<em>그 뿐 아니라</em> 스와이프 할 때 <strong>삽입된 페이지의 DOM 엘리먼트가 브라우저 성능</strong>에 심각한 영향을 미치고 있습니다.</p>

<p><img src="/images/portal/post/2018-08-23-ZUM-Pilot-partjun/mobile-zum-devtool.png" alt="m.zum.com-devtool" width="600px" />
<em>스와이프할 때마다 증가하는 노드와 리스너</em></p>
<blockquote>
  <p>모바일 페이지 전체를 한바퀴 둘러보면 3500개가 넘는 DOM 엘리먼트가 포함된 <strong>무거운</strong> 웹 페이지가 되어버립니다.</p>
</blockquote>

<p>저는 Vue.js의 Virtual DOM 기능을 활용하여 <strong>현재 보이는 페이지와 좌,우(스와이프 시 보여질 페이지) 페이지</strong>의 DOM만을 렌더링하고,
당장 보여줄 필요가 없는 나머지 페이지의 DOM은 렌더링하지 않도록 했습니다.
이렇게 구현함으로서 DOM Query 및 렌더링 성능을 크게 향상시킬 수 있었습니다.</p>

<p><img src="/images/portal/post/2018-08-23-ZUM-Pilot-partjun/virtual-dom.jpg" alt="Virtual DOM을 통한 성능 향상" />
<em>렌더링되는 DOM 엘리먼트의 수 자체를 줄임으로써 큰 성능 향상을 노릴 수 있습니다.</em></p>

<blockquote>
  <p>제 파일럿 프로젝트에서 만든 페이지와 실 서비스 페이지의 구성 요소는 다르고,
Virtual DOM을 이용해도 메모리에 있는 DOM 노드의 수 자체가 줄어드는 것은 아닙니다.<br />
하지만 서비스되고 있는 페이지는 카테고리의 DOM 수가 800개 이상이고 
더 복잡한 DOM 구조를 가지므로 렌더링 및 DOM Query에서 큰 성능 향상을 기대할 수 있습니다.</p>
</blockquote>

<h2 id="모바일-줌-cms">모바일 줌 CMS</h2>
<p><img src="/images/portal/post/2018-08-23-ZUM-Pilot-partjun/mobile-cms-test.gif" alt="구현된 모바일 CMS 테스트" />
<em>구현된 CMS 테스트 화면</em></p>

<h3 id="개요-1">개요</h3>
<p>모바일 줌 페이지의 네비게이션을 감추거나 보이게 스케줄링하고, 
순서를 바꾸는 기능을 포함하는 CMS를 구현하는 프로젝트였습니다.
저는 앞서 만든 모바일 줌 컴포넌트를 그대로 활용, <strong>미리보기</strong> 기능을 구현하여 아래와 같은 화면을 구성하게 되었습니다.</p>

<p><img src="/images/portal/post/2018-08-23-ZUM-Pilot-partjun/mobile-cms.jpg" alt="모바일 CMS" width="600px" />
<em>크게 좌측의 CMS 네비게이션, CMS 본문 그리고 오른쪽에 CMS 미리보기 화면이 있습니다.</em></p>

<h3 id="컴포넌트-구성-1">컴포넌트 구성</h3>
<p><img src="/images/portal/post/2018-08-23-ZUM-Pilot-partjun/mobile-cms-component.jpg" alt="모바일 CMS 컴포넌트 구성" />
CMS는 모바일 줌 화면보다 간단하게 구성했습니다.</p>

<ul>
  <li>CMS 네비게이션
    <ul>
      <li>CMS 본문 화면을 전환합니다.</li>
    </ul>
  </li>
  <li>CMS 본문 컴포넌트
    <ul>
      <li>조작할 내용에 해당하는 CMS 본문 컴포넌트입니다.</li>
      <li>모바일 줌의 페이지 컴포넌트와 마찬가지로 공통 기능을 추상화했습니다.</li>
    </ul>
  </li>
  <li>CMS 적용 결과 미리보기
    <ul>
      <li>모바일 줌 컴포넌트를 그대로 사용하여 미리보기 화면을 구현했습니다.</li>
    </ul>
  </li>
</ul>

<h3 id="서버-구성-1">서버 구성</h3>
<p><img src="/images/portal/post/2018-08-23-ZUM-Pilot-partjun/mobile-cms-server.jpg" alt="모바일 CMS 서버" />
모바일 줌 페이지와 마찬가지로 CMS도 Controller-Service-Repository 레이어링을 사용했습니다.</p>
<ul>
  <li>스프링 시큐리티
    <ul>
      <li>로그인 페이지에서 인증된 사용자만이 CMS 페이지와 API 등을 사용할 수 있도록 구성했습니다.</li>
    </ul>
  </li>
  <li>스프링 스케줄
    <ul>
      <li>등록된 스케줄을 실행하기 위한 기능을 구현했습니다(아래에서 자세한 설명)
        <blockquote>
          <p>CMS에서 지원하는 기능이 많아진다면 기능별, 모듈별 레이어링을 하는 것이 더 좋을 것 같다는 생각이 들었습니다.</p>
        </blockquote>
      </li>
    </ul>
  </li>
</ul>

<h3 id="개발-포인트-3">개발 포인트</h3>
<h4 id="페이지-라우팅">페이지 라우팅</h4>
<p>Vue.js는 같은 레벨에서 분리된 두 개의 라우터, 다시말해 보조 라우터(Auxiliary Route)를 지원하지 않습니다.<br />
따라서 미리보기 용도로 사용하는 <em>모바일 줌 컴포넌트</em>가 라우터를 사용하고 있기 때문에 CMS는 최상위 라우터를 사용할 수 없었습니다. <br />
그래서 저는 메뉴에 따라 다른 <strong>Query parameter를 사용</strong>하여 라우터의 역할을 하도록 구현했습니다.
<img src="/images/portal/post/2018-08-23-ZUM-Pilot-partjun/mobile-cms-routing.jpg" alt="모바일 CMS 라우팅" /></p>

<p>이를 위해 두 가지 작업이 필요했습니다.<br />
첫 번째는 미리보기가 라우팅될 때 Query Parameter를 그대로 다음 페이지에 가져가는 것이었습니다.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">router</span><span class="p">.</span><span class="nx">beforeEach</span><span class="p">((</span><span class="nx">to</span><span class="p">,</span> <span class="k">from</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">hasQueryParams</span> <span class="o">=</span> <span class="p">(</span><span class="nx">route</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="o">!!</span><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">route</span><span class="p">.</span><span class="nx">query</span><span class="p">).</span><span class="nx">length</span><span class="p">;</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="nx">hasQueryParams</span><span class="p">(</span><span class="k">from</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">hasQueryParams</span><span class="p">(</span><span class="nx">to</span><span class="p">)){</span> <span class="c1">// 쿼리 파라미터가 있을 때 파라미터 유지</span>
    <span class="nx">next</span><span class="p">({</span><span class="na">name</span><span class="p">:</span> <span class="nx">to</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span> <span class="na">query</span><span class="p">:</span> <span class="k">from</span><span class="p">.</span><span class="nx">query</span><span class="p">});</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">next</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">});</span></code></pre></figure>

<p>두 번째는 라우터 변화를 감시하는 watch 설정입니다.<br />
CMS 네비게이션을 클릭했을 때 더미 라우터(named router지만 이름이 없는)를 변경하기 때문입니다. 
더미 라우터의 값이 변할 때에도 아래 함수는 실행됩니다.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">watch</span><span class="p">:</span> <span class="p">{</span>
      <span class="dl">'</span><span class="s1">$route</span><span class="dl">'</span><span class="p">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">to</span><span class="p">,</span> <span class="k">from</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 라우터가 변할 때</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">getNavigation</span><span class="p">();</span>         <span class="c1">// 쿼리 파라미터를 파싱, 해당하는 본문 컴포넌트 로드</span>
      <span class="p">}</span>
    <span class="p">}</span></code></pre></figure>

<blockquote>
  <p>Vue.js는 라우팅과 관련된 추가 설정이 아주 간편합니다.  <br />
기능이 너무 강력해 오히려 익히기 힘든 Angular의 Guard보다 더 쉽게, 입맛에 맞게 설정할 수 있을 것 같습니다.</p>
</blockquote>

<h4 id="네비게이션-순서-변경-및-onoff">네비게이션 순서 변경 및 ON/OFF</h4>
<p>CMS의 기본 기능은 네비게이션 컨트롤입니다.<br />
네비게이션의 상태를 <strong>보이게 혹은 보이지 않게 설정</strong>하거나 네비게이션의 <strong>순서를 변경</strong>하는 기능입니다.</p>

<p>드래그 앤 드랍을 이용해 순서를 바꾸거나 버튼을 이용해 숨김 여부를 설정할 수 있게 구현했습니다.
또, 어떻게 보이는지 우측 미리보기를 이용해 바로 확인할 수 있습니다.</p>

<p><img src="/images/portal/post/2018-08-23-ZUM-Pilot-partjun/mobile-cms-navi-control.gif" alt="모바일 CMS 네비게이션 컨트롤" /></p>

<h4 id="네비게이션-스케줄링">네비게이션 스케줄링</h4>
<p>CMS에서 가장 주요했던 기능은 화면에서 입력한 시간에 맞춰 네비게이션을 보이거나 보이지 않게 하는 네비게이션 스케줄링 기능입니다.
<img src="/images/portal/post/2018-08-23-ZUM-Pilot-partjun/mobile-cms-navi-schedule.jpg" alt="모바일 CMS 네비게이션 스케줄링" /></p>

<p>저는 Spring Schedule을 이용하여 <strong>1분마다 스케줄 메소드를 실행</strong>시키는 방법으로 구현했습니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Scheduled</span><span class="o">(</span><span class="n">cron</span> <span class="o">=</span> <span class="s">"1 0/1 * * * *"</span><span class="o">)</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">navScheduleExecute</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">navScheduleService</span><span class="o">.</span><span class="na">executeNavigationSchedule</span><span class="o">();</span> <span class="c1">// 스케줄 처리 로직 실행</span>
  <span class="o">}</span></code></pre></figure>

<p>구체적인 과정은 아래와 같습니다.<br />
<img src="/images/portal/post/2018-08-23-ZUM-Pilot-partjun/mobile-cms-schedule.jpg" alt="모바일 CMS 스케줄링" /></p>

<ul>
  <li>이 과정들은 Transaction 처리됩니다.
    <ol>
      <li>실행 시간을 초과했고 실행되지 않은 스케줄 쿼리</li>
      <li>쿼리된 스케줄에 따라 네비게이션 상세 정보 변경, 스케줄 실행 완료 처리</li>
      <li>네비게이션 캐시 eviction</li>
    </ol>
  </li>
</ul>

<p>CMS 서버를 재시작했을 때에도 등록된 스케줄을 처리해야 한다는 점을 신경썼고, 
스케줄이 실행되어 네비게이션이 변경되었을 때 네비게이션 캐시를 eviction 하도록 구현했습니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="cm">/**
 * 매 분 1초마다 실행되는 스케줄 업데이트 메소드
 * @see com.zum.pilotproject.bean.NavigationScheduler
 */</span>
<span class="nd">@CacheEvict</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">"navigation"</span><span class="o">,</span> <span class="n">allEntries</span> <span class="o">=</span> <span class="kc">true</span><span class="o">)</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">executeNavigationSchedule</span><span class="o">()</span> <span class="o">{</span>

  <span class="n">val</span> <span class="n">time</span> <span class="o">=</span> <span class="o">(</span><span class="k">new</span> <span class="nc">Date</span><span class="o">()).</span><span class="na">getTime</span><span class="o">();</span>

  <span class="c1">// 실행되지 않은 스케줄 쿼리</span>
  <span class="n">val</span> <span class="n">changed</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">navScheduleRepository</span>
                    <span class="o">.</span><span class="na">findAllByIsExecutedAndTimeIsLessThanEqualOrderByTimeAsc</span><span class="o">(</span><span class="kc">false</span><span class="o">,</span> <span class="n">time</span><span class="o">);</span>

  <span class="c1">// 변경 작업</span>
  <span class="n">changed</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="k">this</span><span class="o">::</span><span class="n">scheduleApply</span><span class="o">);</span>

<span class="o">}</span></code></pre></figure>

<p>이번 프로젝트에서는 네비게이션 ON/OFF 스케줄만 구현했지만 스케줄 객체를 구체화하는 것만으로
순서 바꾸기, 이름 바꾸기 등의 기능을 추가할 수 있을 것이라고 생각합니다.</p>

<blockquote>
  <p>하지만 등록된 스케줄이 없을 때에도 메소드가 실행된다는 점이 아쉽습니다. 
기회가 된다면 Reactive X(RxJAVA)를 이용해 Call-back 스타일의 스케줄링도 구현해보고 싶네요.</p>
</blockquote>

<h1 id="후기">후기</h1>

<h2 id="개발하며-느꼈던-vuejs의-장단점">개발하며 느꼈던 Vue.js의 장단점</h2>
<h3 id="장점-happy-coding">장점: Happy Coding!</h3>
<h4 id="1-webpack-based">1. Webpack based</h4>
<p>Scala 기반의 서버 프레임워크인 <em>Play framework가 Spring보다 나은 점</em>이라는 글을 보며 공감했던 내용이 있습니다. 
Spring은 핫 리로드 지원이 약해 개발자의 개발-테스트 리듬을 망친다는 내용이었죠.<br />
그런 점에서 Webpack Dev Server를 지원하는 Vue.js를 통한 프론트엔드 개발은 정말 즐겁습니다.<br />
CTRL + S만으로 띄워놓은 창이 변하니까요!<br />
게다가 크로스 브라우징을 위한 Babel을 비롯해 수많은, 빠르게 변해가는 모듈과 플러그인 적용이 쉽다는 점도 매력적입니다.</p>
<blockquote>
  <p>최근 LESS나 SASS같은 css preprocessor를 넘어 JS까지 이용해 CSS에 변화를 주는 PostCSS가 관심을 받고 있습니다.
차후 PostCSS의 플러그인을 적용해야 할 때에도 프로젝트에 큰 변화를 줄 필요가 없다는 점이 아주 매력적입니다.</p>
</blockquote>

<h4 id="2-easy-and-fast-smooth-learning-curve">2. Easy and Fast, smooth Learning curve</h4>
<p>저는 Angular를 공부해왔지만 아직도 하나도 모르는 것 같습니다.<br />
너무 많은 기능과 선택 사항, 그리고 라이프사이클을 가지니까요.<br />
하지만 Vue.js는 벌써 할만한데? 라는 느낌입니다. 
훨씬 완만한 러닝 커브에 개발자를 배려한 쉽고 명확한 코드는 아주 매력적입니다.</p>

<blockquote>
  <p>하지만…</p>
</blockquote>

<h3 id="단점-there-is-no-sliver-bullet">단점: There is no sliver bullet</h3>
<p>제가 가장 좋아하는 소프트웨어 엔지니어링 명언입니다.<br />
어디에나 쓸 수 있는 완벽한 것은 없다고 하죠. 
제가 파일럿 프로젝트를 진행하며 느낀 Vue.js의 단점은 학습 성취도가 떨어져서 느끼는 문제일 수도 있고, 
다른 프레임워크(저의 경우는 Angular)와 비슷하게 사용하려다 보니 생긴 문제일 수도 있습니다.
하지만 저와 같은 개발자도 많을 것이라 생각하여 경험을 공유하고자 아래와 같이 정리해 보았습니다.</p>

<h4 id="1-라우팅">1. 라우팅</h4>
<p>앞서 설명드린대로 Vue.js는 보조 라우터(Auxiliary Route)를 사용하지 못합니다. 미리 정해놓은 라우터 하이라키로 작동할 뿐이죠. 
Vue router 프로젝트의 이슈란을 보면 주기적으로 언급되고 있지만 필요한 use case가 있는지 논의하고 있다는 답변만 있습니다.</p>

<p>그들의 주장대로 보조 라우터를 <em>반드시</em> 사용해야만 하는 use case는 없을지도 모릅니다.<br />
하지만 점점 복잡해지고 다양해지는 웹 어플리케이션에서 사용하지 <strong>못하는</strong> 것과 사용하지 <strong>않는</strong> 것은 너무나도 다르다고 생각합니다.</p>

<h4 id="2-데이터-변화-감지">2. 데이터 변화 감지</h4>
<p>Angular는 데이터의 변화에 따라 컴포넌트를 언제, 어떻게 다시 그릴지를 정하는 ChangeDetectionStrategy라는 옵션과
OnChanges 메소드 등이 있습니다. 하지만 Vue.js에서는 그런 상세한 컨트롤을 할 수 없죠.<br />
데이터가 변할 때마다 다시 그립니다. 그 변하는 과정을 컨트롤하고 싶다면 데이터 변화 자체를 컨트롤해야 합니다.</p>

<blockquote>
  <p>조금 더 자세하게 적자면…</p>
</blockquote>

<p>Vue.js에서 변화를 감지하는 데이터는 Object.defineProperty를 이용해 set/get 프로퍼티를 선언하고,<br />
get과 set 프로퍼티를 통해 데이터가 변할 때, Watcher 객체가 DOM 렌더링 작업을 다음 ‘tick’에 수행하도록 예약합니다.  <br />
그리고 DOM이 렌더링 되는 ‘tick’에 예약된 작업을 수행합니다. 하지만 ‘tick’을 컨트롤할 수는 없습니다.<br />
결국 데이터가 변했을 때 의도적으로 <strong>다시 그리지 않게</strong> 하지는 못 한다는 것입니다.</p>

<h4 id="3-이벤트">3. 이벤트</h4>
<p>Angular는 Spring과 유사한 형태의 DI를 이용합니다.<br />
서비스나 컴포넌트의 객체를 만들고, Decorator(Spring의 Autowired 어노테이션과 비슷한)를 이용해 객체를 주입받아서 사용할 수 있습니다. 
Vue.js는 ECMA6의 Import를 이용해 다른 곳에 선언된 객체나 메소드를 사용할 수 있습니다만, 컴포넌트 ‘객체’의 ‘이벤트’를
발생시키는데는 무리가 있습니다. 기본적으로 컴포넌트 객체를 참조할 수는 없으니까요. (객체 Holder를 이용할 수는 있겠네요).</p>

<p>아래와 같이 컴포넌트가 중첩되어 있는 구성에서 이벤트를 전달할 방법을 생각해 봅시다.</p>

<p><img src="/images/portal/post/2018-08-23-ZUM-Pilot-partjun/event-dispatch.jpg" alt="Event Dispatch" />
<em>D 컴포넌트에서 발생한 클릭 이벤트를 어떻게 ⓐ 컴포넌트로 전달해야 할까요?</em></p>

<p>이벤트가 발생한 D 컴포넌트부터 <strong>순서대로 D -&gt; C -&gt; B -&gt; A -&gt; ⓐ 순으로 전달</strong>하는 것이 일반적이지만<br />
단순히 이벤트를 <em>전달</em>하기 위해 모든 컴포넌트에 이벤트 핸들링 하는 것은 너무 지루하고 복잡한 작업입니다.</p>

<p>이 문제 해결을 위해 몇 가지 방법이 제시되고 있습니다.</p>

<ul>
  <li>
    <p><a href="https://kr.vuejs.org/v2/guide/components.html#%EB%B9%84-%EB%B6%80%EB%AA%A8-%EC%9E%90%EC%8B%9D%EA%B0%84-%ED%86%B5%EC%8B%A0">전역 이벤트 버스 객체</a>를 만들어 이벤트를 발생시키고 구독하는 방법이 있습니다.
일반적인 문제를 간단하게 해결할 수 있지만 복잡한 이벤트 처리에는 좋지 않습니다. 또, 컴포넌트가 global scope의 이벤트를 참조해야하니 잠재적인 문제가 생길 수도 있습니다.</p>
  </li>
  <li>
    <p><a href="https://vuex.vuejs.org/kr/">Vuex</a>라는 라이브러리를 사용할 수 있습니다.<br />
Vuex Store를 통해 데이터의 변화를 커밋하고 데이터의 변화를 <strong>구독하고 있는 컴포넌트에서 처리</strong>하는 방법입니다. 
전역 이벤트 버스와 비슷하지만 더 다양한 기능들을 제공합니다.</p>
  </li>
  <li>
    <p>Vue.js 2.2버전에서 추가된 provide / inject를 이용하는 방법도 있습니다.<br />
상위 컴포넌트에 <strong>하위 컴포넌트에서 조작할 데이터</strong>를 가지는 객체를 만들어 놓고, 하위 컴포넌트에서 그 <strong>객체를 주입받는 방법</strong>입니다.
데이터 변화를 감지하기 위해서 직접 Object.defineProperty를 이용해 선언하고 데이터 변경을 핸들링해야 하는 어려움이 있습니다.</p>
  </li>
</ul>

<p>프로젝트에 따라 어떤 방법을 선택할지, 어떤 과정으로 처리할지 등 컴포넌트간 이벤트 전달에 대해 생각해 볼 필요가 있습니다. 
컴포넌트가 많고 종속 관계가 복잡하다면 생각하는 시간이 더 길어질 겁니다.</p>

<h3 id="그럼에도">그럼에도…</h3>
<p>Vue.js는 훌륭한 프론트엔드 프레임워크입니다. Github의 Star가 그걸 증명합니다…라고는 말할 수 없지만<br />
프론트엔드 프레임워크, 라이브러리의 홍수 속에서 <em>배우기 쉽고 사용하기 쉬운 프레임워크</em>라는 점 하나만으로도 굉장합니다. 
더 쉽고 빠르게, 현대적인 프론트엔드 개발을 <strong>협업</strong>해야 한다면 저는 자신있게 Vue.js를 추천하겠습니다.</p>

<h2 id="파일럿-프로젝트를-진행하며">파일럿 프로젝트를 진행하며…</h2>
<p>약 한 달간 진행한 파일럿 프로젝트는 사용해보지 않았던 Vue.js를 비롯해 다양한 라이브러리를 
이용해 실제 서비스되고 있는 사이트와 유사한 형태로 개발하는 재미있는 과제였습니다.</p>

<p>줌 인터넷의 서비스는 어떤 식으로 되어 있고, 어떤 정보를 제공하는지 파악하고
실제 서비스와 유사하게 직접 구현해 보니 어려운 점도 있었고, 난해한 부분도 있었습니다. 
하지만 그런 난관을 헤쳐나가며 프로젝트와 파이널 리뷰를 진행하니 개발자로서 조금 더 성장한 느낌이 듭니다.</p>

<p>앞으로 줌 인터넷에서 진행하게 될 업무들도 즐겁게, 값지게 보낼 수 있었으면 좋겠습니다.</p>

<p><img src="/images/portal/post/2018-08-23-ZUM-Pilot-partjun/bye.png" alt="BYE" /></p>
<div style="text-align: center;">
  <span style="background: linear-gradient(to right, red, orange, yellow, green, cyan, blue, violet); 
              -webkit-text-fill-color: transparent; 
              -webkit-background-clip: text; 
              font-size: 24px;
              width: 400px;
              height: 40px;
              line-height: 40px;
              text-align: center;
              display: inline-block;">
  Happy Coding with ZUM internet!
  </span>
</div>
:ET
I"<blockquote>
  <p>제가 줌인터넷 포털개발팀에서 일하고 싶었던 이유 중 하나가<br />
바로 <code class="language-plaintext highlighter-rouge">신입사원 파일럿 프로젝트</code> 였습니다.<br />
신입 개발자 혼자서 주어진 주제와 기술들로 프로젝트를 진행하고,<br />
함께 일 할 동료들로 부터 코드 리뷰를 받고 개선하는 과정을 꼭 경험해보고 싶었기 때문입니다.</p>
</blockquote>

<blockquote>
  <p>이 글을 통해 지난 6주간 신입 개발자로서 파일럿 프로젝트를 진행한 과정과 결과, 느낀 점을 공유하고자 합니다.</p>
</blockquote>

<h2 id="1-파일럿-프로젝트-주제">1. 파일럿 프로젝트 주제</h2>
<p>저에게 주어진 파일럿 프로젝트 주제는 <code class="language-plaintext highlighter-rouge">개발 컨텐츠 공유 서비스</code>였습니다.<br />
유익한 개발 블로그 글이나 영상을 팀원들간에 공유할 수 있는 서비스를 만드는 것이었습니다.</p>

<p>(완성된 서비스의 메인 페이지)
<img src="/images/portal/post/2019-04-22-ZUM-Pilot-integer/main.png" alt="" /></p>

<p>처음 파일럿 프로젝트 주제를 들었을 때는 제 귀를 의심했습니다.<br />
약 5개월 전부터 개인적으로 <a href="https://github.com/Integerous/goQuality-dev-contents">고퀄리티 개발 컨텐츠 모음</a>이라는 Github 저장소를 운영하고 있었는데,<br />
Github 저장소에 모인 데이터를 활용하여 토이 프로젝트로 만들고자 했던 서비스가<br />
우연히 파일럿 프로젝트의 주제로 정해진 것입니다!</p>

<p><img src="/images/portal/post/2019-04-22-ZUM-Pilot-integer/surprised1.gif" alt="" /></p>

<p>물론 팀 내에서 사용할 서비스이기 때문에 기획의 방향이 조금은 달랐지만,<br />
만들고 싶었던 서비스를 회사 업무의 일환으로 만들 수 있다는 것에 행복했습니다.<br />
<!-- (업무가 곧 취미요, 취미가 곧 업무로다!) --></p>

<p>파일럿 프로젝트 <strong>주제의 궁극적인 목표</strong>는<br />
<code class="language-plaintext highlighter-rouge">개발 컨텐츠 공유 서비스</code>를 통해서 팀원들 간 기술 공유를 활성화하는 것이었습니다.<br />
때문에 잘 만들면 팀에서 계속 사용할 서비스가 될 수 있다는 생각에 가슴이 설레었습니다.</p>

<p>파일럿 프로젝트가 끝나면 버려지는 서비스가 아니라, 계속 개선해 나갈 서비스를 만들겠다고 다짐하며<br />
비장한 마음으로 프로젝트를 시작했습니다.</p>

<h2 id="2-개발-스펙">2. 개발 스펙</h2>

<p><img src="../../images/portal/post/2019-04-22-ZUM-Pilot-integer/tech.png" width="600" /></p>

<p>주어진 개발 스펙은 포털개발팀의 기술 스택 중 핵심적인 것들로 이루어졌습니다.<br />
때문에 실무에서 쓰게 될 기술들을 미리 학습하고 사용해보는 기회를 갖게 되는 점이 좋았습니다.</p>

<p>게다가 팀에서는 <strong>Java 8, Spring boot, Gradle, JPA, Vue.js</strong> 등 비교적 최신 기술들을 사용하고 있어서,<br />
제대로 학습하고 싶은 의지도 생기고, Documentation이 잘 되어있는 기술들이기 때문에<br />
학습을 위해 고대 문서(?)들을 발굴해야 할 필요도 없었습니다.</p>

<p>즉, 개발 외적인 부분들(기술 스택, 업무 환경) 때문에 스트레스를 받을 일은 없어서<br />
개발에만 온전히 집중할 수 있었습니다.</p>

<p>하지만 Front-end 개발은 처음이었고, JavaScript를 제대로 학습한 적이 없었습니다.<br />
때문에 Vue.js를 사용해서 화면을 구현해야하는 것이 마음 한 켠에 짐으로 남아있었습니다.</p>

<h2 id="3-개발-일정">3. 개발 일정</h2>

<p>주어진 시간은 단 6주!<br />
6주 안에 개발 스펙의 필수 기술을 모두 사용하여 필수 기능을 구현해야 했습니다.</p>

<p>하지만 1차 리뷰는 4주 차에 예정되어 있었습니다.<br />
때문에 팀원들의 피드백을 제대로 받으려면 사실상 4주 안에 완성하고,<br />
남은 2주 간 피드백을 바탕으로 코드를 개선하거나 선택 기술/기능을 추가해야 했습니다.</p>

<p>생각보다 더 시간이 촉박했습니다. Vue.js는 커녕 JavaScript도 모르던 상태였고,<br />
MyBatis만 써봤기 때문에 ERD를 설계하고 Entity를 작성하는 시점에<br />
JPA에 대한 무지가 계속 발목을 잡았습니다.</p>

<p>마음은 선택 기술과 선택 기능들까지 모두 구현하고 싶었지만,<br />
일정을 계산해보니 필수 기술과 기능을 구현하는 것만으로도 벅찰 것으로 예상되었습니다.</p>

<p>그래서 체계적인 일정 관리를 위해<br />
<strong>Notion</strong>으로 <a href="https://www.notion.so/integerous/4b6b1977dfe4496ca4a0df27ddf12312">파일럿 프로젝트 현황판</a>을 만들어서 프로젝트 진행 상황을 관리했습니다.</p>

<p><img src="/images/portal/post/2019-04-22-ZUM-Pilot-integer/schedule.png" alt="" /></p>

<p>이 Notion 페이지의 URL을 팀원분들께 공유해서<br />
현재 무엇을 개발하고 있고, 어디까지 진행되었는지 자유롭게 확인 할 수 있도록 했습니다.</p>

<p>그리고 Notion에 정리한 구현 순서를 팀원분들께 보여드리면서 조언을 구했습니다.<br />
써보지 않은 기술들의 학습과 구현에 드는 시간을 예상하기 어려웠기 때문입니다.<br />
그 결과, 구현의 우선 순위를 조정하여 일정을 조금이나마 단축할 수 있었습니다.</p>

<h2 id="4-사전-학습">4. 사전 학습</h2>

<p>4주 안에 처음 사용해보는 기술로 서비스를 구현해야 했지만,  <br />
기술에 대해 전혀 이해하지 않고 구현만 할 수는 없었습니다.</p>

<p>그래서 1주차에는 핵심적인 기술이면서도 처음 사용해보는 기술들인<br />
<strong>JPA</strong>, <strong>JavaScript</strong>, <strong>Vue.js</strong> 를 집중적으로 학습하는 시간을 가졌습니다.</p>

<p><img src="../../images/portal/post/2019-04-22-ZUM-Pilot-integer/books.jpg" width="600" /></p>

<p><strong><em>JavaScript</em></strong> 의 경우 Vue.js를 사용하기 위한 준비 단계로 생각하고,<br />
‘인사이드 자바스크립트’를 읽으며 기초적인 개념을 빠르게 익히는 것에 집중했습니다.</p>

<p><strong><em>JPA</em></strong> 는 처음 사용해보았기 때문에 <strong>영속성</strong>의 개념과 <strong>연관관계 매핑</strong>를 우선적으로 학습하고,<br />
구현을 하면서 궁금한 부분 위주로 학습을 병행했습니다. (하지만 JPA 책은 6주 동안 매일 펼쳐야 했습니다.)</p>

<p><strong><em>Vue.js</em></strong> 는 <a href="https://kr.vuejs.org/v2/guide/">한글 문서</a>에 잘 정리되어 있는 가이드로 전체적인 개념을 공부하고,<br />
회사에서 Inflearn(인프런)의 강의들을 지원해주기 때문에 Vue.js 강의들로 실습을 해보며<br />
Vue.js에 대해 알아가기 시작했습니다.</p>

<h2 id="5-테이블-설계">5. 테이블 설계</h2>

<p>1주차에 사전학습을 빠르게 마무리하고, ERD를 작성하면서 서비스의 흐름을 구상했습니다.</p>

<p>ERD 설계를 처음 해보았기 때문에, 모든 테이블을 바로 작성하기보다는<br />
핵심 테이블인 회원과 게시물, 댓글 테이블만 만들고 관계를 고민한 후에,<br />
팀원들의 피드백을 받으면서 테이블을 추가해나갔습니다.</p>

<p><img src="../../images/portal/post/2019-04-22-ZUM-Pilot-integer/1st_erd.png" width="700" /></p>

<p>단순한 서비스였지만 지속적으로 팀원들의 피드백을 받으면서 ERD를 고치고 또 고치는 과정을 거쳤습니다.<br />
특히, 팀원분들이 실무적인 관점에서 성능 상 문제가 될 부분들을 조언해주셔서<br />
논리적인 관점만 생각하고 작성된 저의 ERD가 조금씩 개선될 수 있었습니다.</p>

<!-- ![](/images/portal/post/2019-04-22-ZUM-Pilot-integer/erd_2nd.png) -->
<p><img src="/images/portal/post/2019-04-22-ZUM-Pilot-integer/final_erd.png" alt="" /></p>

<p>하지만 프로젝트를 구현할수록 저의 어설픈 ERD 설계가 뒤통수를 치기 시작했습니다.<br />
때문에 단순한 서비스라도 설계가 정말 중요하다는 것을 6주 내내 절감했습니다.</p>

<h2 id="6-back-end-개발">6. Back-end 개발</h2>

<h3 id="61-back-end-요청응답-흐름">6.1. Back-end 요청/응답 흐름</h3>

<p>기본적인 Back-end 요청/응답의 흐름은 <code class="language-plaintext highlighter-rouge">Controller  - Service - Repository</code>로 이어지는 구조입니다.</p>

<!-- ![](/images/portal/post/2019-04-22-ZUM-Pilot-integer/flow.png) -->
<p><img src="/images/portal/post/2019-04-22-ZUM-Pilot-integer/flow1.png" alt="" /></p>

<p>더 자세한 흐름은,</p>

<ol>
  <li><strong><em>Vue.js</em></strong>
    <ul>
      <li>사용자의 요청을 받아 비동기적(Axios)으로 서버에 요청을 전달</li>
      <li>받은 응답을 다시 사용자에게 전달</li>
    </ul>
  </li>
  <li><strong><em>Controller</em></strong>
    <ul>
      <li>클라이언트로 부터 사용자의 요청을 전달 받아서 해당하는 로직을 Service 계층에 요청</li>
      <li>받은 응답을 다시 화면에 전달</li>
    </ul>
  </li>
  <li><strong><em>Service</em></strong>
    <ul>
      <li>Controller 계층에서 전달받은 요청을 처리하기 위한 Query를 Repository 계층에 요청</li>
      <li>받은 응답으로 로직 처리를 마무리</li>
      <li>결과를 Controller 계층에 전달</li>
    </ul>
  </li>
  <li><strong><em>Repository</em></strong>
    <ul>
      <li>Service 계층에서 요청한 Query로 DB에 질의</li>
      <li>결과를 다시 Service 계층에 전달</li>
    </ul>
  </li>
  <li><strong><em>DB</em></strong>
    <ul>
      <li>Repository 계층에서 질의한 Query를 수행</li>
      <li>결과를 Repository 계층에 전달</li>
    </ul>
  </li>
</ol>

<p><strong>그 외의 흐름은 2가지가 있습니다.</strong><br />
    - 팀원들의 공유 랭킹을 집계하는 로직을 <strong><em>Spring Scheduler</em></strong>를 사용하여 매 주 금요일 오전 6시에 수행<br />
    - JPA의 쿼리 메서드로 처리하기 복잡한 쿼리들을 <strong><em>QueryDSL</em></strong>로 처리</p>

<h3 id="62-사용자-랭킹-집계">6.2. 사용자 랭킹 집계</h3>

<p>팀원들이 개발 컨텐츠를 적극적으로 공유하도록 독려하기 위해, 사용자 랭킹 시스템을 구현했습니다.</p>

<p><img src="/images/portal/post/2019-04-22-ZUM-Pilot-integer/rank.png" alt="" /></p>

<p>오른쪽 상단에 [사용자 랭킹 보기] 버튼을 누르면 빨간색으로 표시된 최근 랭킹표가 나타납니다.</p>

<blockquote>
  <p>매 주 랭킹 1위에게는 팀장님이 스타벅스 커피를 사주신다고..ㅎ</p>
</blockquote>

<p>사용자 랭킹은 공유한 컨텐츠 수와 좋아요 및 댓글 수를 기준으로<br />
<strong><em>Spring Scheduler</em></strong>를 사용하여 매 주 금요일 오전 6시에 집계됩니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Scheduled</span><span class="o">(</span><span class="n">cron</span> <span class="o">=</span> <span class="s">"0 0 6 * * FRI"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">countRank</span><span class="o">()</span> <span class="o">{</span>

    <span class="c1">// 랭킹 집계 로직</span>
<span class="o">}</span>
</code></pre></div></div>

<p>처음에는 <strong><em>Spring Batch</em></strong>를 사용할 예정이었습니다.<br />
팀에서 개발하는 다양한 서비스에서 Batch를 사용하고 있고,<br />
Batch로 구현하면 기능을 확장하기 수월하다고 생각했기 때문입니다.</p>

<p>하지만 현재 기획상으로는 <strong>Job이 랭킹을 집계하는 것 하나 뿐</strong>이기 때문에<br />
<strong>Spring Scheduler</strong>로 충분한 상황이었습니다.</p>

<p>고민을 거듭한 끝에, 기한이 정해져있는 프로젝트에서 개인적인 욕심을 채우기 보다는<br />
일정에 맞추는 것이 우선이라 생각되어 <strong>Spring Scheduler</strong>로 가볍게 구현하고,<br />
아쉽지만 <strong>Spring Batch</strong>를 학습하고 사용하는 것은 추후로 미루었습니다.</p>

<p>그리고 매 주 갱신되는 사용자 랭킹을 집계하기 위해서는,</p>

<blockquote>
  <ol>
    <li>지난 주에 컨텐츠를 등록한 사용자들</li>
    <li>1번에 해당하는 각 사용자가 공유한 컨텐츠의 갯수</li>
    <li>해당 기간에 공유한 컨텐츠에 달린 댓글 수와 좋아요 수의 합</li>
  </ol>
</blockquote>

<p>이렇게 세 가지 데이터가 필요했습니다.<br />
그런데 처음에는 아래의 코드에서 처럼 3가지 데이터를 각각 DB에 요청했습니다.</p>

<p>(이 코드는 1차 리뷰에서 굉장히 많은 문제점을 피드백 받은 <strong><em>th레기 코드</em></strong> 입니다!!)</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Scheduled</span><span class="o">(</span><span class="n">cron</span> <span class="o">=</span> <span class="s">"0 * * ? * *"</span><span class="o">)</span> <span class="c1">// 1분 마다 (테스트용)</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">countRank</span><span class="o">()</span> <span class="o">{</span>

    <span class="c1">// 1. 지난 7일간 등록된 게시물 목록 가져오기</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Post</span><span class="o">&gt;</span> <span class="n">postsLastWeek</span> <span class="o">=</span> <span class="n">postRepository</span>
            <span class="o">.</span><span class="na">findAllByCreatedAtBetween</span><span class="o">(</span><span class="nc">LocalDateTime</span><span class="o">.</span><span class="na">now</span><span class="o">().</span><span class="na">minusWeeks</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="nc">LocalDateTime</span><span class="o">.</span><span class="na">now</span><span class="o">());</span>

    <span class="c1">// 2. 게시물 작성자 목록 뽑기 (중복 제거)</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">membersLastWeek</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

    <span class="k">for</span><span class="o">(</span><span class="nc">Post</span> <span class="n">item</span> <span class="o">:</span> <span class="n">postsLastWeek</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(!</span><span class="n">membersLastWeek</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">getMember</span><span class="o">()))</span> <span class="o">{</span>
            <span class="n">membersLastWeek</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">getMember</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// 3. MemberRank 세팅해서 DB에 저장</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">Member</span> <span class="n">member</span> <span class="o">:</span> <span class="n">membersLastWeek</span><span class="o">)</span> <span class="o">{</span>

        <span class="nc">MemberRank</span> <span class="n">memberRank</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MemberRank</span><span class="o">();</span>
        <span class="n">memberRank</span><span class="o">.</span><span class="na">setMember</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>

        <span class="c1">// 3.1. 해당 사용자가 작성한 게시물의 개수 세팅</span>
        <span class="kt">int</span> <span class="n">postCnt</span> <span class="o">=</span> <span class="n">postRepository</span><span class="o">.</span><span class="na">countByMemberAndCreatedAtBetween</span><span class="o">(</span>
                                        <span class="n">member</span><span class="o">,</span>
                                        <span class="nc">LocalDateTime</span><span class="o">.</span><span class="na">now</span><span class="o">().</span><span class="na">minusWeeks</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span>
                                        <span class="nc">LocalDateTime</span><span class="o">.</span><span class="na">now</span><span class="o">());</span>
        <span class="n">memberRank</span><span class="o">.</span><span class="na">setPostCnt</span><span class="o">(</span><span class="n">postCnt</span><span class="o">);</span>

        <span class="c1">// 3.2. 해당 사용자가 작성한 게시물의 랭크포인트 합산 세팅</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Post</span><span class="o">&gt;</span> <span class="n">postByThisMember</span> <span class="o">=</span> <span class="n">postRepository</span><span class="o">.</span><span class="na">findAllByMemberIdxAndCreatedAtBetween</span><span class="o">(</span>
                                                        <span class="n">member</span><span class="o">.</span><span class="na">getIdx</span><span class="o">(),</span>
                                                        <span class="nc">LocalDateTime</span><span class="o">.</span><span class="na">now</span><span class="o">().</span><span class="na">minusWeeks</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span>
                                                        <span class="nc">LocalDateTime</span><span class="o">.</span><span class="na">now</span><span class="o">());</span>
        <span class="kt">int</span> <span class="n">postsPoints</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Post</span> <span class="n">post</span> <span class="o">:</span> <span class="n">postByThisMember</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">postsPoints</span> <span class="o">+=</span> <span class="n">post</span><span class="o">.</span><span class="na">getRankPoint</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">memberRank</span><span class="o">.</span><span class="na">setPostsPoints</span><span class="o">(</span><span class="n">postsPoints</span><span class="o">);</span>

        <span class="c1">// 3.3. 해당 랭크의 랭크포인트 세팅</span>
        <span class="kt">int</span> <span class="n">postPoint</span> <span class="o">=</span> <span class="n">postCnt</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">postsPoints</span><span class="o">;</span>
        <span class="n">memberRank</span><span class="o">.</span><span class="na">setRankPoint</span><span class="o">(</span><span class="n">postPoint</span><span class="o">);</span>

        <span class="c1">// 3.4. 각 MemberRank를 DB에 저장</span>
        <span class="n">memberRankRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">memberRank</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 4. 이번주 데이터에 순위 세팅해서 DB에 저장</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">MemberRank</span><span class="o">&gt;</span> <span class="n">memberRankList</span> <span class="o">=</span> <span class="n">memberRankRepository</span>
            <span class="o">.</span><span class="na">findAllByCreatedAtBetweenOrderByRankPointDesc</span><span class="o">(</span>
                    <span class="nc">LocalDateTime</span><span class="o">.</span><span class="na">now</span><span class="o">().</span><span class="na">minusSeconds</span><span class="o">(</span><span class="mi">30</span><span class="o">),</span> <span class="nc">LocalDateTime</span><span class="o">.</span><span class="na">now</span><span class="o">());</span>
    
    <span class="c1">// 5. MemberRank DB에 방금 넣은 데이터에만 순위부여 (테스트용)</span>
    <span class="kt">int</span> <span class="n">rank</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="nc">MemberRank</span> <span class="n">memberRank</span> <span class="o">:</span> <span class="n">memberRankList</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">rank</span><span class="o">++;</span>
        <span class="n">memberRank</span><span class="o">.</span><span class="na">setRank</span><span class="o">(</span><span class="n">rank</span><span class="o">);</span>
        <span class="n">memberRankRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">memberRank</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>다양한 문제점을 피드백 받았지만, 우선 <strong>DB 접근 횟수 최소화</strong>를 위해서<br />
필요한 데이터들을 Query 하나로 가지고 오고 싶었습니다.</p>

<p>처음에는 JPA의 쿼리 메소드로 작성했지만 한계가 있었고, JPA의 <strong>Native Query</strong>로 작성을 시도했습니다.<br />
하지만 SQL 작성에 능숙하지 않아서 계속 <strong>문법 오류</strong>가 발생했고, 어디서 발생한 오류인지 확인이 어려웠습니다.<br />
그렇다고 당장 SQL 문법을 제대로 학습하기에는 시간이 부족했습니다.</p>

<p>그래서 컴파일 단계에서 문법 오류를 잡을 수 있고,<br />
SQL 방언에 상관 없이 코드 작성하듯 쿼리를 작성할 수 있는 <strong><em>QueryDSL</em></strong>을 사용하기 시작했습니다.</p>

<p>QueryDSL은 개발 스펙 상 필수 기술에 속했지만,<br />
JPA의 쿼리 메소드만으로 쉽고 빠르게 개발이 가능했기 때문에 처음에는 사용 할 필요성을 못느꼈었습니다.<br />
하지만 QueryDSL을 사용하면서 왜 <strong>Type-safe</strong>한 것이 편리한 지 몸소 느낄 수 있었습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RequiredArgsConstructor</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PostRepositoryImpl</span> <span class="kd">implements</span> <span class="nc">PostRepositoryCustom</span><span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">JPAQueryFactory</span> <span class="n">queryFactory</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">RankCountDto</span><span class="o">&gt;</span> <span class="nf">rankCount</span><span class="o">(</span><span class="nc">LocalDateTime</span> <span class="n">start</span><span class="o">,</span> <span class="nc">LocalDateTime</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>

        <span class="k">return</span> <span class="n">queryFactory</span>
                    <span class="o">.</span><span class="na">select</span><span class="o">(</span><span class="nc">Projections</span><span class="o">.</span><span class="na">fields</span><span class="o">(</span>
                            <span class="nc">RankCountDto</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">post</span><span class="o">.</span><span class="na">member</span><span class="o">,</span> <span class="n">post</span><span class="o">.</span><span class="na">member</span><span class="o">.</span><span class="na">count</span><span class="o">().</span><span class="na">as</span><span class="o">(</span><span class="s">"postCnt"</span><span class="o">)))</span>
                    <span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">post</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">groupBy</span><span class="o">(</span><span class="n">post</span><span class="o">.</span><span class="na">member</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="n">post</span><span class="o">.</span><span class="na">createdAt</span><span class="o">.</span><span class="na">between</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">end</span><span class="o">))</span>
                    <span class="o">.</span><span class="na">fetch</span><span class="o">();</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>위와 같이, QueryDSL을 사용해서 1번 데이터와 2번 데이터를 DB에서 한 번에 가지고 오도록 구현했습니다.<br />
그리고 아직도 부족한 점이 많지만 아래와 같이 랭킹 집계 로직을 개선할 수 있었습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Scheduled</span><span class="o">(</span><span class="n">cron</span> <span class="o">=</span> <span class="s">"*/30 * * * * *"</span><span class="o">)</span> <span class="c1">// 30초 마다 (테스트용)</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">countRank</span><span class="o">()</span> <span class="o">{</span>

    <span class="nc">LocalDateTime</span> <span class="n">aWeekAgo</span> <span class="o">=</span> <span class="nc">LocalDateTime</span><span class="o">.</span><span class="na">now</span><span class="o">().</span><span class="na">minusWeeks</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="nc">LocalDateTime</span> <span class="n">now</span> <span class="o">=</span> <span class="nc">LocalDateTime</span><span class="o">.</span><span class="na">now</span><span class="o">();</span>

    <span class="c1">// 지난주에 게시물 올린 사용자 &amp; 등록한 게시물 수</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">RankCountDto</span><span class="o">&gt;</span> <span class="n">rankCountLastWeek</span> <span class="o">=</span> <span class="n">postRepository</span><span class="o">.</span><span class="na">rankCount</span><span class="o">(</span><span class="n">aWeekAgo</span><span class="o">,</span> <span class="n">now</span><span class="o">);</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Rank</span><span class="o">&gt;</span> <span class="n">rankList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

    <span class="k">for</span><span class="o">(</span><span class="nc">RankCountDto</span> <span class="n">rankDto</span> <span class="o">:</span> <span class="n">rankCountLastWeek</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">rankDto</span><span class="o">.</span><span class="na">getMember</span><span class="o">();</span>
        <span class="nc">Long</span> <span class="n">postCnt</span> <span class="o">=</span> <span class="n">rankDto</span><span class="o">.</span><span class="na">getPostCnt</span><span class="o">();</span>

        <span class="c1">// 해당 사용자가 작성한 게시물의 포인트 합산 세팅</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Post</span><span class="o">&gt;</span> <span class="n">postsByThisMember</span> <span class="o">=</span>
                <span class="n">postRepository</span><span class="o">.</span><span class="na">findAllByMemberIdxAndCreatedAtBetween</span><span class="o">(</span><span class="n">member</span><span class="o">.</span><span class="na">getIdx</span><span class="o">(),</span> <span class="n">aWeekAgo</span><span class="o">,</span> <span class="n">now</span><span class="o">);</span>

        <span class="nc">Long</span> <span class="n">postsPoints</span> <span class="o">=</span> <span class="mi">0L</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="nc">Post</span> <span class="n">post</span> <span class="o">:</span> <span class="n">postsByThisMember</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">postsPoints</span> <span class="o">+=</span> <span class="n">post</span><span class="o">.</span><span class="na">getRankPoint</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="c1">// 랭크포인트 세팅</span>
        <span class="nc">Long</span> <span class="n">rankPoint</span> <span class="o">=</span> <span class="n">postCnt</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">postsPoints</span><span class="o">;</span>

        <span class="c1">// Rank 생성</span>
        <span class="nc">Rank</span> <span class="n">rank</span> <span class="o">=</span> <span class="nc">Rank</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
                <span class="o">.</span><span class="na">countDay</span><span class="o">(</span><span class="n">now</span><span class="o">)</span>
                <span class="o">.</span><span class="na">postCnt</span><span class="o">(</span><span class="n">postCnt</span><span class="o">)</span>
                <span class="o">.</span><span class="na">postsPoints</span><span class="o">(</span><span class="n">postsPoints</span><span class="o">)</span>
                <span class="o">.</span><span class="na">rankPoint</span><span class="o">(</span><span class="n">rankPoint</span><span class="o">)</span>
                <span class="o">.</span><span class="na">member</span><span class="o">(</span><span class="n">member</span><span class="o">)</span>
                <span class="o">.</span><span class="na">build</span><span class="o">();</span>

        <span class="c1">// 리스트에 저장</span>
        <span class="n">rankList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">rank</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 랭킹포인트 높은 순서로 정렬</span>
    <span class="n">rankList</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="k">new</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="nc">Rank</span><span class="o">&gt;()</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="nc">Rank</span> <span class="n">o1</span><span class="o">,</span> <span class="nc">Rank</span> <span class="n">o2</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">o1</span><span class="o">.</span><span class="na">getRankPoint</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">o2</span><span class="o">.</span><span class="na">getRankPoint</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">o1</span><span class="o">.</span><span class="na">getRankPoint</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">o2</span><span class="o">.</span><span class="na">getRankPoint</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">});</span>

    <span class="c1">// 랭킹 세팅</span>
    <span class="kt">int</span> <span class="n">ranking</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">Rank</span> <span class="n">rank</span> <span class="o">:</span> <span class="n">rankList</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ranking</span><span class="o">++;</span>
        <span class="n">rank</span><span class="o">.</span><span class="na">setRanking</span><span class="o">(</span><span class="n">ranking</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="n">rankRepository</span><span class="o">.</span><span class="na">saveAll</span><span class="o">(</span><span class="n">rankList</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="63-컨텐츠-필터와-페이징-처리">6.3. 컨텐츠 필터와 페이징 처리</h3>

<p>저는 이 서비스가 페이스북이나 인스타그램 처럼 <strong>가볍게, 자주 사용되길 바라는 마음으로 개발</strong>했습니다.<br />
때문에 페이징 처리도 <strong>무한 스크롤</strong>을 적용했습니다.</p>

<p>하지만 <a href="https://cyberx.tistory.com/82">무한스크롤, 페이징 혹은 “더보기” 버튼? 어떤 걸 써야할까</a> 라는 글을 읽고 무한 스크롤의 단점들을 알게 되었고, 다양한 기준(카테고리, 사용자, 등록일, 인기도)의 게시물 필터 기능을 넣어서 이를 보완하고자 했습니다.</p>

<p>그런데 게시물이 필터링 된 상태에서 무한스크롤이 동작하면, 필터링 된 게시물들만 DB에 요청해야 하기 때문에 아래의 코드처럼 각 필터별로 다른 Query를 날려야 했습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * 게시물 Top10 (기준: 댓글 수 + 좋아요 수)
 * @return 인기순 상위 10개 게시물
 */</span>
<span class="kd">public</span> <span class="nc">Page</span><span class="o">&lt;</span><span class="nc">PostResponseDto</span><span class="o">&gt;</span> <span class="nf">listTopTen</span><span class="o">()</span> <span class="o">{</span>

    <span class="nc">PageRequest</span> <span class="n">pageRequest</span> <span class="o">=</span> <span class="nc">PageRequest</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="nc">Sort</span><span class="o">.</span><span class="na">Direction</span><span class="o">.</span><span class="na">DESC</span><span class="o">,</span> <span class="s">"rankPoint"</span><span class="o">,</span> <span class="s">"likeCnt"</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">postRepository</span><span class="o">.</span><span class="na">findAll</span><span class="o">(</span><span class="n">pageRequest</span><span class="o">).</span><span class="na">map</span><span class="o">(</span><span class="nl">PostResponseDto:</span><span class="o">:</span><span class="k">new</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/**
 * 게시물 필터 (Tag Name)
 * @param tagName 게시물 박스에서 클릭한 태그 이름
 * @param pageable 페이징 처리를 위한 객체
 * @return 해당 태그가 포함된 게시물 목록
 */</span>
<span class="kd">public</span> <span class="nc">Page</span><span class="o">&lt;</span><span class="nc">PostResponseDto</span><span class="o">&gt;</span> <span class="nf">listFilteredByTagName</span><span class="o">(</span><span class="nc">String</span> <span class="n">tagName</span><span class="o">,</span> <span class="nc">Pageable</span> <span class="n">pageable</span><span class="o">)</span> <span class="o">{</span>

    <span class="k">return</span> <span class="n">postRepository</span><span class="o">.</span><span class="na">findAllByTagName</span><span class="o">(</span><span class="n">tagName</span><span class="o">,</span> <span class="n">pageable</span><span class="o">).</span><span class="na">map</span><span class="o">(</span><span class="nl">PostResponseDto:</span><span class="o">:</span><span class="k">new</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// ... 게시물 필터 (Member) 생략 </span>

<span class="cm">/**
 * 게시물 필터 (Date)
 * @param createdDate 게시물 박스에서 클릭한 날짜
 * @return 해당 날짜에 등록된 게시물 목록
 */</span>
<span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">PostResponseDto</span><span class="o">&gt;</span> <span class="nf">listFilteredByDate</span><span class="o">(</span><span class="nc">String</span> <span class="n">createdDate</span><span class="o">)</span> <span class="o">{</span>

    <span class="c1">// 등록일 00시부터 24시까지</span>
    <span class="nc">LocalDateTime</span> <span class="n">start</span> <span class="o">=</span> <span class="nc">LocalDateTime</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="nc">LocalDate</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">createdDate</span><span class="o">),</span> <span class="nc">LocalTime</span><span class="o">.</span><span class="na">MIN</span><span class="o">);</span>
    <span class="nc">LocalDateTime</span> <span class="n">end</span> <span class="o">=</span> <span class="nc">LocalDateTime</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="nc">LocalDate</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">createdDate</span><span class="o">),</span> <span class="nc">LocalTime</span><span class="o">.</span><span class="na">MAX</span><span class="o">);</span>

    <span class="k">return</span> <span class="n">postRepository</span>
                    <span class="o">.</span><span class="na">findAllByCreatedAtBetween</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">end</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                    <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">PostResponseDto:</span><span class="o">:</span><span class="k">new</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>이 때 <strong>카테고리(tag)</strong>로 게시물을 필터링 하는 경우,<br />
각 게시물은 최대 3개까지의 카테고리(tag)를 가질 수 있기 때문에 해당 카테고리를 포함하는 모든 게시물을 질의해야 했기 때문에, <strong>QueryDSL</strong>을 사용하여 다소 복잡한 Query를 작성하면서도 페이징 처리를 할 수 있었습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * 게시물 필터 (Tag Name)
 */</span>
<span class="nd">@Override</span>
<span class="kd">public</span> <span class="nc">Page</span><span class="o">&lt;</span><span class="nc">Post</span><span class="o">&gt;</span> <span class="nf">findAllByTagName</span><span class="o">(</span><span class="nc">String</span> <span class="n">tagName</span><span class="o">,</span> <span class="nc">Pageable</span> <span class="n">pageable</span><span class="o">)</span> <span class="o">{</span>

    <span class="nc">QueryResults</span><span class="o">&lt;</span><span class="nc">Post</span><span class="o">&gt;</span> <span class="n">results</span> <span class="o">=</span> <span class="n">queryFactory</span>
            <span class="o">.</span><span class="na">selectFrom</span><span class="o">(</span><span class="n">post</span><span class="o">)</span>
            <span class="o">.</span><span class="na">innerJoin</span><span class="o">(</span><span class="n">postTag</span><span class="o">)</span>
                <span class="o">.</span><span class="na">on</span><span class="o">(</span><span class="n">post</span><span class="o">.</span><span class="na">idx</span><span class="o">.</span><span class="na">eq</span><span class="o">(</span><span class="n">postTag</span><span class="o">.</span><span class="na">post</span><span class="o">.</span><span class="na">idx</span><span class="o">))</span>
            <span class="o">.</span><span class="na">innerJoin</span><span class="o">(</span><span class="n">tag</span><span class="o">)</span>
                <span class="o">.</span><span class="na">on</span><span class="o">(</span><span class="n">tag</span><span class="o">.</span><span class="na">idx</span><span class="o">.</span><span class="na">eq</span><span class="o">(</span><span class="n">postTag</span><span class="o">.</span><span class="na">tag</span><span class="o">.</span><span class="na">idx</span><span class="o">))</span>
            <span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="n">tag</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">eq</span><span class="o">(</span><span class="n">tagName</span><span class="o">))</span>
            <span class="o">.</span><span class="na">orderBy</span><span class="o">(</span><span class="n">post</span><span class="o">.</span><span class="na">idx</span><span class="o">.</span><span class="na">desc</span><span class="o">())</span>
                <span class="o">.</span><span class="na">limit</span><span class="o">(</span><span class="n">pageable</span><span class="o">.</span><span class="na">getPageSize</span><span class="o">())</span>
                <span class="o">.</span><span class="na">offset</span><span class="o">(</span><span class="n">pageable</span><span class="o">.</span><span class="na">getOffset</span><span class="o">())</span>
            <span class="o">.</span><span class="na">fetchResults</span><span class="o">();</span>

    <span class="k">return</span> <span class="k">new</span> <span class="nc">PageImpl</span><span class="o">&lt;&gt;(</span><span class="n">results</span><span class="o">.</span><span class="na">getResults</span><span class="o">(),</span> <span class="n">pageable</span><span class="o">,</span> <span class="n">results</span><span class="o">.</span><span class="na">getTotal</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="7-핵심-기능의-흐름">7. 핵심 기능의 흐름</h2>
<p>이 서비스의 핵심 기능은 <strong>컨텐츠 등록</strong> 기능입니다.<br />
사용자는 단지 컨텐츠의 카테고리를 선택하고, URL만 입력하면 끝입니다.<br />
이 단순한 기능의 흐름을 보면, 서비스가 어떻게 동작하는지 알 수 있습니다.</p>

<h3 id="71-전체-흐름">7.1. 전체 흐름</h3>
<p><img src="/images/portal/post/2019-04-22-ZUM-Pilot-integer/flow2.png" alt="" /></p>

<h3 id="72-사용자-요청">7.2. 사용자 요청</h3>
<p><img src="/images/portal/post/2019-04-22-ZUM-Pilot-integer/flow_vue.png" alt="" /></p>
<ul>
  <li><strong>URL 정규식 체크</strong>
    <ul>
      <li>Vue.js로 렌더링된 화면단에서, 사용자가 등록을 시도한 URL의 모양새를 정규식으로 확인합니다.</li>
      <li>URL의 모양새가 아닌 경우, 에러 메세지를 띄웁니다.</li>
    </ul>
  </li>
  <li><strong>Axios 비동기 요청</strong>
    <ul>
      <li>URL의 모양새인 경우, 컨텐츠를 등록하는 POST 요청을 비동기로 날립니다.</li>
    </ul>
  </li>
</ul>

<h3 id="73-controller">7.3. Controller</h3>
<p><img src="/images/portal/post/2019-04-22-ZUM-Pilot-integer/flow_controller.png" alt="" /></p>
<ul>
  <li><strong>요청 처리</strong>
    <ul>
      <li>Controller에서는 요청을 화면단에서 넘어온 요청을 받고, Service 계층에 로직 처리를 위임합니다.</li>
    </ul>
  </li>
  <li><strong>결과 응답</strong>
    <ul>
      <li>Service 계층에서 넘어온 로직 처리 결과(메세지)를 화면단에 응답해줍니다.</li>
    </ul>
  </li>
</ul>

<h3 id="74-service">7.4. Service</h3>
<p><img src="/images/portal/post/2019-04-22-ZUM-Pilot-integer/flow_service1.png" alt="" /></p>
<ul>
  <li><strong>Http 프로토콜 추가 및 trim()</strong>
    <ul>
      <li>사용자가 URL 입력 시 Http 프로토콜을 생략하거나 공백을 넣은 경우,<br />
올바른 URL이 될 수 있도록 Http 프로토콜을 추가해주고, 공백을 제거해줍니다.</li>
    </ul>
  </li>
  <li><strong>URL 접속 확인</strong>
    <ul>
      <li>화면단에서 모양새만 확인한 URL이 실제 리소스로 연결되는지 <code class="language-plaintext highlighter-rouge">HttpUrlConnection</code>으로 테스트합니다.</li>
      <li>이 때, 빠른 응답을 위해 Request Method를 <strong>GET이 아닌 HEAD를 사용</strong>했습니다.<br />
(HEAD 메소드는 GET 메소드의 응답 결과의 Body는 가져오지 않고, Header만 확인하기 때문에 GET 메소드에 비해 응답속도가 빠릅니다.)</li>
    </ul>
  </li>
</ul>

<p><img src="/images/portal/post/2019-04-22-ZUM-Pilot-integer/flow_service2.png" alt="" /></p>

<ul>
  <li><strong>Jsoup 이미지, 제목 파싱</strong>
    <ul>
      <li>URL 접속 확인결과 유효하면 Jsoup을 사용해서 입력된 URL의 이미지와 제목을 파싱합니다.</li>
      <li>이미지는 Open Graphic Tag를 우선적으로 파싱하고, 없을 경우 첫 번째 이미지와 제목을 파싱합니다.</li>
      <li>컨텐츠에 이미지가 없을 경우, 미리 설정해둔 기본 이미지를 사용하고, 제목이 없을 경우 생략합니다.</li>
    </ul>
  </li>
</ul>

<h3 id="75-repository">7.5. Repository</h3>
<p><img src="/images/portal/post/2019-04-22-ZUM-Pilot-integer/flow_repo.png" alt="" /></p>
<ul>
  <li><strong>컨텐츠 저장</strong>
    <ul>
      <li>URL 유효성 체크와 이미지, 제목 파싱이 끝난 컨텐츠는 DB에 저장합니다.</li>
      <li>저장된 컨텐츠는 다시 Repository - Service - Controller를 거쳐 화면단에 송출됩니다.</li>
    </ul>
  </li>
</ul>

<h2 id="8-front-end-개발">8. Front-end 개발</h2>

<p>Front-end 개발은 처음이었기 때문에 아예 감이 없었습니다.<br />
그 전까지는 Front-end 개발을 <strong>화면을 꾸미는 일</strong> 정도로 생각했는데 크나큰 착각이었습니다.</p>

<p>1주 차에 사전학습을 하면서 쉬운 편에 속한다는 Vue.js를 공부했음에도 Front-end 개발이 쉽지 않다는 생각이 들었고, 개발이 진행될수록 Front-end 개발이 Back-end 개발보다 더 어렵게 느껴졌습니다.</p>

<p><img src="/images/portal/post/2019-04-22-ZUM-Pilot-integer/difficult.gif" alt="" /></p>

<p>특히, JavaScript 개념이 약한 상태에서 Vue.js의 생명주기를 고려하며 개발하는 것은 쉽지 않았습니다.<br />
하지만 서비스의 구조가 단순했기 때문에 Front-end의 구조도 비교적 단순하게 구성할 수 있었습니다.</p>

<h3 id="81-front-end-프로젝트-구조">8.1. Front-end 프로젝트 구조</h3>
<p><img src="/images/portal/post/2019-04-22-ZUM-Pilot-integer/front.png" alt="" /></p>

<p>Front-end 코드는 frontend 폴더에 모아서 Back-end 코드와 구분했습니다.<br />
꼭 구분해야 하는 것은 아니었지만, Front-end 개발에 익숙하지 않은 상황이라<br />
Back-end 코드와 별개로 생각하고 관리하고 싶었습니다.</p>

<h3 id="82-vuejs-컴포넌트-구조">8.2. Vue.js 컴포넌트 구조</h3>
<p><img src="/images/portal/post/2019-04-22-ZUM-Pilot-integer/components.png" alt="" /></p>

<p>싱글 페이지로 구현했기 때문에 컴포넌트의 구조와 역할은 단순했습니다.<br />
추후에 더 많은 기능을 개발한다면 Vuex 등의 상태관리 도구가 필요할 것으로 생각됩니다.</p>

<h3 id="83-vuejs-컴포넌트-계층">8.3. Vue.js 컴포넌트 계층</h3>
<p><img src="/images/portal/post/2019-04-22-ZUM-Pilot-integer/front_arch.png" alt="" /></p>

<p>기본적으로 <strong>App.vue</strong> 라는 최상위 컴포넌트와 자식 컴포넌트들로 구분했습니다.<br />
그리고 <strong>PostList</strong> 컴포넌트의 경우 게시물 목록이기 때문에 <strong>PostItem</strong> 컴포넌트를 내포하고 있고,<br />
<strong>PostItem</strong>은 댓글에 해당하는 <strong>PostComment</strong> 컴포넌트를 내포하고 있는 형태입니다.</p>

<p>때문에 각 컴포넌트에서 발생한 Event를 <strong>App.vue</strong> 컴포넌트로 올려서(Event emit)<br />
모든 API 콜을 <strong>App.vue</strong>에서 담당하고, 그 결과를 자식 컴포넌트들에 내려주는 방식(Props down)으로 구현했지만, <strong>App.vue</strong>까지 올라가기 번거로운 <strong>PostItem</strong> 컴포넌트와 <strong>PostComment</strong> 컴포넌트의 Event는 자체적으로 API 콜을 요청하고 응답받도록 구현했습니다.</p>

<h3 id="84-vuejs의-watch를-이용한-무한-스크롤-구현">8.4. Vue.js의 watch를 이용한 무한 스크롤 구현</h3>
<p>Vue.js는 Vue 인스턴스의 데이터 변경을 관찰하고 이에 반응하는 watch 속성을 제공합니다.<br />
저는 이 watch 속성을 이용해서 비동기적으로 사용자의 스크롤 변화를 감지했고,<br />
스크롤이 바닥에 닿으면 그 다음 페이지를 로딩하도록 구현했습니다.</p>

<p>우선, 컴포넌트 초기화 단계(created())에서부터 스크롤을 감지하기 시작합니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">created</span><span class="p">()</span> <span class="p">{</span>
      <span class="c1">// 스크롤 감지</span>
      <span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">scroll</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">bottom</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">bottomVisible</span><span class="p">();</span>
      <span class="p">});</span>

    <span class="p">},</span>
</code></pre></div></div>

<p>아래의 <code class="language-plaintext highlighter-rouge">bottomVisible()</code> 메소드로 스크롤이 바닥에 닿았는지 체크하고, bottom 변수에 결과를 담습니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nx">bottomVisible</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">scrollY</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">pageYOffset</span><span class="p">;</span> <span class="c1">// 스크롤되어 올라간 높이 (이미 지나간 화면 높이)</span>
    <span class="kd">let</span> <span class="nx">visible</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">.</span><span class="nx">clientHeight</span><span class="p">;</span> <span class="c1">// 화면 높이</span>
    <span class="kd">let</span> <span class="nx">pageHeight</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">.</span><span class="nx">scrollHeight</span><span class="p">;</span> <span class="c1">// 전체 높이</span>
    <span class="kd">let</span> <span class="nx">bottomOfPage</span> <span class="o">=</span> <span class="nx">visible</span> <span class="o">+</span> <span class="nx">scrollY</span> <span class="o">&gt;=</span> <span class="nx">pageHeight</span><span class="p">;</span>

    <span class="k">return</span> <span class="nx">bottomOfPage</span> <span class="o">||</span> <span class="nx">pageHeight</span> <span class="o">&lt;</span> <span class="nx">visible</span><span class="p">;</span>
<span class="p">},</span>
</code></pre></div></div>

<p>만약 스크롤이 바닥에 닿았을 경우, watch 속성이 bottom 변수의 변화를 감지해서<br />
그 다음 페이지를 로딩하는 로직을 실행시킵니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">watch</span><span class="p">:</span> <span class="p">{</span>
    <span class="nx">bottom</span><span class="p">(</span><span class="nx">bottom</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">bottom</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">lastPage</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">loading</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> <span class="c1">// 로딩스피너 시작</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">page</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

            <span class="k">if</span><span class="p">((</span><span class="k">this</span><span class="p">.</span><span class="nx">page</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">&gt;=</span> <span class="k">this</span><span class="p">.</span><span class="nx">propsPosts</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
                    <span class="k">this</span><span class="p">.</span><span class="nx">loading</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">// 로딩스피너 종료</span>
                    <span class="k">this</span><span class="p">.</span><span class="nx">$emit</span><span class="p">(</span><span class="dl">'</span><span class="s1">addList</span><span class="dl">'</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">page</span><span class="p">);</span> <span class="c1">// 다음 페이지 게시물들 추가</span>
                <span class="p">},</span> <span class="mi">200</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>로직이 실행되면, 다음 페이지 로딩시 로딩스피너가 돌기 시작합니다.<br />
이 때, 사용자가 인지할 수 있도록 0.2초의 텀을 주고 로딩스피너를 종료합니다.</p>

<h2 id="9-느낀-점">9. 느낀 점</h2>
<p>개발 공부를 시작한 지 1년이 지났지만 프로젝트를 제대로 끝내 본 경험이 없었는데,<br />
파일럿 프로젝트를 하면서 처음으로 하나의 서비스를 완성할 수 있었습니다.</p>

<p>책이나 온라인 강의에 있는 예제를 따라서 서비스를 만들어 보는 것과,<br />
서비스의 A부터 Z까지 직접 만들어보는 것은 정말 하늘과 땅의 차이라는 것을 깨달았습니다.</p>

<p>책이나 강의에서는 제대로 동작하는 코드만 나와있지만,<br />
직접 서비스를 설계하고 개발할 때에는 내가 생각해낸 코드와 구글링한 코드를 사용하기 때문에<br />
훨씬 많은 문제와 마주해야 했습니다.</p>

<p>그리고 그 문제들을 해결하는 과정에서 제대로 이해하지 못하고 있던 개념들을 발견할 수 있었고,<br />
밤낮 없이 고민하고 헤매다가 문제를 해결했을 때는 개발의 참 재미를 느낄 수 있었습니다.</p>

<p>파일럿 프로젝트를 하기 전까지의 저는 <strong>‘개발 = 무언가를 만드는 일’</strong> 이라고 스스로 정의했다면,<br />
파일럿 프로젝트를 마친 지금은 <strong>‘개발 = 문제를 해결하는 일’</strong> 이라고 다시 정의하게 되었습니다.</p>

<p>앞으로 포털개발팀에서 실제 서비스를 개발하면 더 어렵고 힘든 문제들을 마주하겠지만,<br />
끊임 없이 공부하고 팀원들과 함께 고민한다면<br />
결국 어떠한 문제라도 해결할 수 있다는 자신감이 생겼습니다!</p>

<p><img src="/images/portal/post/2019-04-22-ZUM-Pilot-integer/ready.gif" alt="" /></p>

<p>긴 글 읽어주셔서 감사합니다!</p>

:ET